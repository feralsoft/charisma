import {match_on} from "./utils.coil"
import {parse_rule} from "./css-parser.coil"
import {run} from "./parse-utils.coil"
import {compile} from "./html-ast.coil"

def post(url, body) = fetch(url, {method: "POST", body: JSON:stringify(body)})

def Or(...@conds) end
def Or:prototype.invoke(arg) = this:conds.any?(|c| c(arg))

let sheets = document:styleSheets.filter(|sheet| {
  if let file_name = sheet:ownerNode:dataset:viteDevId
    return file_name.has?("a.css") or file_name.has?("b.css")
  end
}).into([])

def* c_product(left, right)
  for l of left
    for r of right
      yield [l r]
    end
  end
end

let query_to_file_path = match_on(:kind){
  def :class_selector({name}) = [str("." name)]
  def :selector_modifier({lhs, rhs}) =
    c_product(query_to_file_path(lhs), query_to_file_path(rhs))
      .map(str:fmt(0 "/&/" 1))
  def :child_selector({lhs, rhs}) =
    c_product(query_to_file_path(lhs), query_to_file_path(rhs))
      .map(str:fmt(0 "/" 1))
  def :attribute_selector_equals({name, value}) =
    [str("[" name "=\"" value "\"]")]
  def :attribute_selector_contains({name, value}) =
    [str("[" name "*=\"" value "\"]")]
  def :attribute_selector_no_match({name}) =
    [str("[" name "]")]
  def :element_selector({name}) = [name]
  def :id_selector({name}) = [str("#" name)]
  def :pseudo_selector_without_args({name}) =
    [str(":" name)]
  def :pseudo_selector_with_args({name, args}) =
    [str(":" name "(" args.map(compile).join(", ") ")")]
  def :pseudo_element_selector({name}) = [str("::" name)]
  def :direct_descendent({lhs, rhs}) =
    c_product(query_to_file_path(lhs), query_to_file_path(rhs))
      .map(str:fmt(0 "/>/" 1))
  def :sibling_selector({lhs, rhs}) =
    c_product(query_to_file_path(lhs), query_to_file_path(rhs))
      .map(str:fmt(0 "/~/" 1))
  def :or({lhs, rhs}) =
    [...query_to_file_path(lhs) ...query_to_file_path(rhs)]
}

def CssDB(entries)
  this:_map = Map{...entries}
end

def* file_cmds(map, path)
  for [sub_path, object] of map
    let current_path = [...path, sub_path]
    -- TODO: it should probably always be an object literal
    if object:selector
      yield {
        path: current_path,
        code: str(object:selector " {\n  " object:properties.join(";\n  ") ";\n}\n")
      }
    end
    yield* file_cmds(object:children, current_path)
  end
end

def* CssDB:prototype.(Symbol:iterator)
  yield* file_cmds(this:_map, [])
end

def CssDB:prototype:insert_property(selector, str_path, property)
  let current_map = this:_map
  let path = str_path:split("/")
  for [sub_path i] of path.zip(1..)
    if let map = current_map(sub_path)
      if i == path.len()
        map:properties:add(compile(property))
      else
        current_map = map:children
      end
    else if i == path.len()
      current_map.set!(sub_path, {
        selector,
        properties: Set[compile(property)]
        children: Map{}
      })
    else
      let map = Map{}
      current_map.set!(sub_path, {
        selector: nil,
        properties: nil,
        children: map
      })
      current_map = map
    end
  end
end

let db = CssDB{}

for {query, properties} of sheets.flat_map(:rules).map(:cssText parse_rule.run 0)
  -- there's a number of paths that we generate
  -- but they all contain the same properties
  -- for eg. :is(a, b).active generates:
  --   ["a/&/.active", "b/&/.active"]
  -- we need a way to tie these all together & choose a main
  -- that the others will listen to.
  -- 
  -- for now we will duplicate & ignore the problem until we have to deal with it
  for path of query_to_file_path(query)
    -- query should be built up from the path
    let actual_query = path:replaceAll("/&/" "")
      .:replaceAll("/" " ")
      
    (!actual_query.has?("/")).assert!("f")
    for property of properties.filter(:kind Set[:property :variable])
      db:insert_property(actual_query, path, property)
    end
  end
end

await db.map(|{path, code}| post("/save_to_file", {path, code}))
  .pipe(Promise:all)

-- a.css
-- .btn {
--   font-size: 20px;
-- }

-- b.css
-- .btn {
--   display: flex;
-- }

-- parsing
-- [current-file=a.css]
--   query = {kind: :class_selector, name: "btn"}
--   properties = ["font-size: 20px"]
--
-- [current-file=b.css] 
--   query = {kind: :class_selector, name: "btn"}
--   properties = ["font-size: 20px"]
