import "./html.coil"
import {parse_decl} from "./css-parser.coil"
import {to_html, compile, to_ast} from "./html-ast.coil"
import plugins from "./plugins"

document:styleSheets.0:rules.take(2).zip(0..).map(|[rule idx]| [parse_decl(rule:cssText).0, idx]).each(|[css_ast_node idx]| {
  let css_decl = to_html(css_ast_node)
  css_decl:setAttribute("data-css-index", idx)
  $(".editor"):append(css_decl)
})

-- idea: split plain-text-value by space & try to parse out values 

def create_signal() = {
  abort_handlers: []
  id: crypto:randomUUID()
  def :destroy
    this:abort_handlers.each(|f| f())
    this:abort_handlers = []
  end
  def :on_abort(cb) = this:abort_handlers:push(cb)
  def :listen(obj event_name cb)
    obj:addEventListener(event_name cb)
    this:on_abort(|| obj:removeEventListener(event_name cb))
  end
}


def init(root)
  for plugin of Object:values(plugins)
    let signal = create_signal()
    let config = {
      root: root
      signal: signal
      def :rebuild(new_root)
        config:eval_css(new_root)
        init(new_root or root)
      end
      def :eval_css(new_root)
        let html_node = (new_root or root):closest("[data-kind=declaration]")
        let ast_node = html_node.to_ast()
        let idx = html_node:getAttribute("data-css-index").as_num()
        document:styleSheets.0:deleteRule(idx)
        document:styleSheets.0:insertRule(compile(ast_node) idx)
      end
    }
    plugin(config)
  end
end

init(document:body)
