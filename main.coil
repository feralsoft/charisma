import "./html.coil"
import {parse_decl} from "./css-parser.coil"
import {run} from "./parse-utils.coil"
import {to_html, compile, to_ast} from "./html-ast.coil"
import {parse_cx_query} from "./cx-parser.coil"
import plugins from "./plugins"
-- import "./diff.coil"

document:styleSheets.0:rules.zip(0..).map(|[rule idx]| [parse_decl.run(rule:cssText).0, idx]).each(|[css_ast_node idx]| {
  let css_decl = to_html(css_ast_node)
  let root_path = "/Users/marcelrusu/Documents/Projects/css-edit/"
  let absolute_path = document:styleSheets.0:ownerNode:getAttribute("data-vite-dev-id")
  let relative_path = absolute_path:slice(root_path.len())

  css_decl:setAttribute("data-css-index", idx)
  css_decl:setAttribute("data-file-path", relative_path)
  css_decl:prepend(:a{
    href: str("vscode://file" absolute_path),
    children: relative_path,
    class: "open-in-vscode"
  })
  $(".--css-edit-editor"):append(css_decl)
})

-- warn on unused query
-- store active keys on editor elements with data attributes

def create_signal() = {
  abort_handlers: []
  id: crypto:randomUUID()
  def :destroy
    this:abort_handlers.each(|f| f())
    this:abort_handlers = []
  end
  def :on_abort(cb) = this:abort_handlers:push(cb)
  def :listen(obj event_name cb)
    obj:addEventListener(event_name cb)
    this:on_abort(|| obj:removeEventListener(event_name cb))
  end
}

def scope_helper(plugin_name) = {
  def :class(name) = str("plugin_" plugin_name "_" name)
  def :data(name) = str("data-plugin_" plugin_name "_" name)
  def :attr(name) = str("plugin_" plugin_name "_" name)
}

def scroll_to(elem)
  $$(".searched.focused").each(|elem| elem:classList:remove("focused"))
  elem:scrollIntoView({block: :center})
  elem:classList:add("focused")
end

def teardown_search
  $$(".searched").each(|elem| elem:classList:remove("searched"))
  $(".--css-edit-editor [type=search]"):remove()
  let editor = $(".--css-edit-editor")
  editor:removeAttribute("data-current-search-idx")
  editor:removeAttribute("data-current-search-last-idx")
  $$("[data-search-idx]").each(|elem| elem:removeAttribute("data-search-idx"))
end

window:addEventListener("keydown" |e| {
  if e:key.pipe(Set["s" "r"]) and e:ctrlKey
    if !$("[type=search]")
      let search = :input{
        type: "search",
        class: "search",
        placeholder: "search..."
        def :onkeyup(e)
          if e:key == "Enter"
            $(".searched.focused"):focus()
            teardown_search()
          else if e:key == "s" and e:ctrlKey
            let prev_idx = $(".--css-edit-editor"):dataset:currentSearchIdx.pipe(parseInt)
            if let elem = $("[data-search-idx=\"" prev_idx + 1 "\"]")
              scroll_to(elem)
              $(".--css-edit-editor"):setAttribute("data-current-search-idx" prev_idx + 1)
            else
              scroll_to($("[data-search-idx=\"0\"]"))
              $(".--css-edit-editor"):setAttribute("data-current-search-idx" 0)
            end
          else if e:key == "r" and e:ctrlKey
            let prev_idx = $(".--css-edit-editor"):dataset:currentSearchIdx.pipe(parseInt)
            if let elem = $("[data-search-idx=\"" prev_idx - 1 "\"]")
              scroll_to(elem)
              $(".--css-edit-editor"):setAttribute("data-current-search-idx" prev_idx - 1)
            else
              let {currentSearchLastIdx} = $(".--css-edit-editor"):dataset
              scroll_to($("[data-search-idx=\"" currentSearchLastIdx "\"]"))
              $(".--css-edit-editor"):setAttribute("data-current-search-idx" currentSearchLastIdx)
            end
          end
        end
        def :oninput(e)
          $$("[data-search-idx]").each(|elem| elem:removeAttribute("data-search-idx"))
          $$(".searched").each(|elem| elem:classList:remove("searched"))
          $(".--css-edit-editor"):setAttribute("data-current-search-idx" 0)
          let search_results = $$(parse_cx_query(e:target:value:trim()))
          $(".--css-edit-editor"):setAttribute("data-current-search-last-idx" search_results:length - 1)
          for [elem idx] of search_results.zip(0..)
            elem:classList:add("searched")
            elem:setAttribute("data-search-idx", idx)
          end
          if let first_result = $("[data-search-idx=\"0\"]")
            scroll_to(first_result)
          end
        end
      }
      $(".--css-edit-editor"):prepend(search)
      search:focus()
    else
      $("[type=search]"):focus()
    end
  end
  if e:key == "Escape"
    teardown_search()
  end
})

-- TODO: toggle this to turn on persisting
let fetching = true

protocol signals

def destroy_all_signals(root)
  root.signals.each(|signal| signal:destroy())
  root:children.each(destroy_all_signals)
end

def init(root)
  destroy_all_signals(root)
  root.signals = []

  for [plugin_name, plugin] of Object:entries(plugins)
    -- store signal on the root
    let signal = create_signal()
    root.signals:push(signal)
    let config = {
      root: root
      signal: signal
      scope: scope_helper(plugin_name)
      async def :rebuild(new_root)
        await config:eval_css(new_root)
        init(new_root or root)
      end
      async def :eval_css(new_root)
        new_root = new_root or root
        -- root might be .--css-edit-editor or <body>.. not sure if this is gonna cause issues later or not - it will :)
        let html_node = new_root:closest("[data-kind=decl][data-css-index]") or new_root.query("[data-kind=decl]")
        -- if what I've updated is just a value in a rule (most the time)
        -- find the sheet & update the rule directly instead of recompiling the entire decl!! this will be huge!
        if !html_node panic!("could not find nearest decl") end
        let ast_node = html_node.to_ast()
        let idx = html_node:getAttribute("data-css-index").as_num()
        let {sheet, attributes} = $("[data-vite-dev-id$=\"" html_node:getAttribute("data-file-path") "\"]")
        sheet:deleteRule(idx)
        sheet:insertRule(compile(ast_node) idx)
        -- TODO: pull this out into a function or something
        if !fetching
          fetching = true
          -- TODO: look into using a websocket
          await fetch("http://localhost:5173/update_css", {
            method: "POST",
            body: JSON:stringify({
              css: sheet:rules.map(:cssText).join("\n")
              file: attributes."data-vite-dev-id":value
            })
          })
          fetching = false
        end
      end
    }
    plugin(config)
  end
end

init(document:body)
