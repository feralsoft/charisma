import "./html.coil"
import {parse_decl} from "./css-parser.coil"
import {run} from "./parse-utils.coil"
import {to_html, compile, to_ast} from "./html-ast.coil"
import {parse_cx_query} from "./cx-parser.coil"
import plugins from "./plugins"

document:styleSheets.0:rules.take(19).zip(0..).map(|[rule idx]| [parse_decl.run(rule:cssText).0, idx]).each(|[css_ast_node idx]| {  
  let css_decl = to_html(css_ast_node)
  let root_path = "/Users/marcelrusu/Documents/Projects/css-edit/"
  let absolute_path = document:styleSheets.0:ownerNode:getAttribute("data-vite-dev-id")
  let relative_path = absolute_path:slice(root_path.len())

  css_decl:setAttribute("data-css-index", idx)
  css_decl:setAttribute("data-file-path", relative_path)
  css_decl:prepend(:a{
    href: str("vscode://file" absolute_path),
    children: relative_path,
    class: "open-in-vscode"
  })
  $(".--css-edit-editor"):append(css_decl)
})

-- warn on unused query
-- store active keys on editor elements with data attributes

def create_signal() = {
  abort_handlers: []
  id: crypto:randomUUID()
  def :destroy
    this:abort_handlers.each(|f| f())
    this:abort_handlers = []
  end
  def :on_abort(cb) = this:abort_handlers:push(cb)
  def :listen(obj event_name cb)
    obj:addEventListener(event_name cb)
    this:on_abort(|| obj:removeEventListener(event_name cb))
  end
}

def scope_helper(plugin_name) = {
  def :class(name) = str("plugin_" plugin_name "_" name)
  def :data(name) = str("data-plugin_" plugin_name "_" name)
  def :attr(name) = str("plugin_" plugin_name "_" name)
}

window:addEventListener("keydown" |e| {
  if e:key == "s" if e:ctrlKey if !$("[type=search]")
    let search = :input{
      type: "search",
      class: "search",
      placeholder: "search..."
      def :oninput(e)
        $$(".searched").each(|elem| elem:classList:remove("searched"))
        $$(parse_cx_query(e:target:value:trim()))
          .each(|elem| elem:classList:add("searched"))
      end
    }
    $(".--css-edit-editor"):prepend(search)
    search:focus()
  end end end
  if e:key == "Escape"
    $$(".searched").each(|elem| elem:classList:remove("searched"))
    $(".--css-edit-editor [type=search]"):remove()
  end
})

-- TODO: toggle this to turn on persisting
let fetching = true

protocol signals

def destroy_all_signals(root)
  root.signals.each(|signal| signal:destroy())
  root:children.each(destroy_all_signals)
end

def init(root)
  destroy_all_signals(root)
  root.signals = []

  for [plugin_name, plugin] of Object:entries(plugins)
    -- store signal on the root
    let signal = create_signal()
    root.signals:push(signal)
    let config = {
      root: root
      signal: signal
      scope: scope_helper(plugin_name)
      async def :rebuild(new_root)
        await config:eval_css(new_root)
        init(new_root or root)
      end
      async def :eval_css(new_root)
        new_root = new_root or root
        -- root might be .--css-edit-editor or <body>.. not sure if this is gonna cause issues later or not
        let html_node = new_root:closest("[data-kind=decl]") or new_root.query("[data-kind=decl]")
        let ast_node = html_node.to_ast()
        let idx = html_node:getAttribute("data-css-index").as_num()
        let {sheet, attributes} = $("[data-vite-dev-id$=\"" html_node:getAttribute("data-file-path") "\"]")
        sheet:deleteRule(idx)
        sheet:insertRule(compile(ast_node) idx)
        if !fetching
          -- make sure
          fetching = true
          -- TODO: use a websocket, it'll be much faster probably
          await fetch("http://localhost:5173/update_css", {
            method: "POST",
            body: JSON:stringify({
              css: sheet:rules.map(:cssText).join("\n")
              file: attributes."data-vite-dev-id":value
            })
          })
          fetching = false
        end
      end
    }
    plugin(config)
  end
end

init(document:body)
