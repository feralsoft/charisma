import {to_ast, to_html} from "../../html-ast.coil"
import "./drag-and-drop.css"
import is_object from "./is_object.js"

def json_to_object(raw_obj)
  if is_object(raw_obj)
    let out = {}
    for [key value] of Object:entries(raw_obj)
      out.key = json_to_object(value)
    end
    return out
  else
    return raw_obj
  end
end

let dragover_preceding = "plugin_drag-and-drop_dragover-preceding"
let dragover_following = "plugin_drag-and-drop_dragover-following"
let dragging = "data-plugin_drag-and-drop_dragging"

def remove_dragover_classes(node) =
  [dragover_preceding dragover_following].each(node:classList:remove)

def drag_and_drop({signal, rebuild, root})
  for draggable of root.query_all(":is([data-kind=rule], [data-kind=variable])")
    draggable:setAttribute("draggable" true)
    signal:listen(draggable "dragstart" |e| {
      draggable:setAttribute(dragging, true)
      e:dataTransfer:dropEffect = "move"
      e:dataTransfer:setData("text/json", JSON:stringify(draggable.to_ast()))
    })
    signal:listen(draggable "dragenter" |e| {
      root.query("[" dragging "]")
        .:compareDocumentPosition(draggable)
        .pipe(Map{ Node:DOCUMENT_POSITION_PRECEDING => dragover_preceding
                   Node:DOCUMENT_POSITION_FOLLOWING => dragover_following }
              draggable:classList:add)
    })
    signal:listen(draggable "dragleave" |e| remove_dragover_classes(draggable))
    signal:listen(draggable "dragover" |e| {
      e:preventDefault()
      e:dataTransfer:dropEffect = "move"
    })
    signal:listen(draggable "drop" |e| {
      e:preventDefault()
      let ast_node = JSON:parse(e:dataTransfer:getData("text/json")).pipe(json_to_object)
      let new_node = to_html(ast_node)
      if draggable:classList:contains(dragover_preceding)
        draggable:before(new_node)
      else
        draggable:after(new_node)
      end
      remove_dragover_classes(draggable)
      $(".--css-edit-editor [" dragging "]"):remove()
      rebuild(new_node)
    })
  end
end

export default drag_and_drop
