import {to_ast, to_html} from "../../html-ast.coil"
import "./drag-and-drop.css"
import is_object from "./is_object.js"

def json_to_object(raw_obj)
  if is_object(raw_obj)
    let out = {}
    for [key value] of Object:entries(raw_obj)
      out.key = json_to_object(value)
    end
    return out
  else
    return raw_obj
  end
end

def drag_and_drop({signal, rebuild, root, scope})  
  def remove_dragover_classes(node) =
    [scope:class(:preceding) scope:class(:following)].each(node:classList:remove)

  for draggable of root.query_all(":is([data-kind=rule], [data-kind=variable])")
    draggable:setAttribute("draggable" true)
    signal:listen(draggable "dragstart" |e| {
      draggable:setAttribute(scope:data(:dragging), true)
      e:dataTransfer:dropEffect = "move"
      e:dataTransfer:setData("text/json", JSON:stringify(draggable.to_ast()))
    })
    signal:listen(draggable "dragenter" |e| {
      root.query("[" scope:data(:dragging) "]")
        .:compareDocumentPosition(draggable)
        .pipe(Map{ Node:DOCUMENT_POSITION_PRECEDING => scope:class(:preceding)
                   Node:DOCUMENT_POSITION_FOLLOWING => scope:class(:following) }
              draggable:classList:add)
    })
    signal:listen(draggable "dragleave" |e| remove_dragover_classes(draggable))
    signal:listen(draggable "dragover" |e| {
      e:preventDefault()
      e:dataTransfer:dropEffect = "move"
    })
    signal:listen(draggable "drop" |e| {
      e:preventDefault()
      let ast_node = JSON:parse(e:dataTransfer:getData("text/json")).pipe(json_to_object)
      let new_node = to_html(ast_node)
      if draggable:classList:contains(scope:class(:preceding))
        draggable:before(new_node)
      else
        draggable:after(new_node)
      end
      remove_dragover_classes(draggable)
      $(".--css-edit-editor [" scope:data(:dragging) "]"):remove()
      rebuild(new_node)
    })
  end
end

export default drag_and_drop
