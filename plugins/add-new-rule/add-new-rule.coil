import "./add-new-rule.css"
import {parse_rule} from "../../css-parser.coil"
import {to_html} from "../../html-ast.coil"

protocol map_ctor

def Object:prototype.map_ctor(Ctor, cb)
  if this instanceof Ctor
    return cb(this)
  else
    return this
  end
end

def add_new_rule({signal, root, rebuild, scope})
  for rules of root.query_all("[data-kind=declaration]:not(:has(.plugin_add_new_rule_btn)) [data-attr=rules]")
    rules:append(:button{
      class: scope:class(:btn),
      children: "+",
      def :onclick(e)
        let new_rule = :div{
          contenteditable: true
          class: scope:class(:unfinished)
          async def :onkeydown(e)
            this:removeAttribute(scope:data(:error))
            e:stopPropagation()
            if e:key == "Backspace"
              if this:innerText == ""
                this:remove()
                rebuild(root:closest("[data-kind=declaration]"))
              end
            else if e:key == "Enter"
              e:preventDefault()
              let css_rule_text = this:innerText:trim()
              if !css_rule_text:endsWith(";")
                css_rule_text = str(css_rule_text ";")
              end
              if let ast_node = try!(|| parse_rule([nil css_rule_text]).0).map_ctor(Error, |e| nil)
                this:replaceWith(to_html(ast_node))
                await rebuild(root:closest("[data-kind=declaration]"))
              else
                this:setAttribute(scope:data(:error), true)
              end
            end
          end
        }
        e:target:replaceWith(new_rule)
        new_rule:focus()
      end
    })
  end
end

export default add_new_rule
