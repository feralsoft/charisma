export protocol matches?

def String:prototype.matches?(str)
  if str:startsWith(this)
    return {result: this, skip: this.len()}
  else
    return false
  end
end

def RegExp:prototype.matches?(str)
  let result = str:match(this)
  if result.nil?() or result:index != 0
    return false
  else
    return {result: result.0, skip: result.0.:length}
  end
end

def _.matches?(str) = {result: str, skip: 0}

export def Parser(...@steps) end
def Parser:prototype.invoke([_ str]) =
  this:steps.reduce(|[result str] parser| parser([result str]), [nil str])

let nid_count = 1
export def Init(@state) end
def Init:prototype.invoke([_ str])
  let nid = nid_count
  nid_count = nid_count + 1
  return [{...this:state nid: nid} str]
end

export def Then(@parser @property) end
def Then:prototype.invoke([state str]) = this:parser([state str])
  .pipe(|[result str]| [{...state this:property => result} str])

export def Skip(@pattern) end
def Skip:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [state str:slice(skip)]
  else
    this.log({state: state, str: str}) Error[]:stack.log() panic!()
  end
end

export def Store(@pattern @property) end
def Store:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [{...state this:property => result} str:slice(skip)]
  else
    this.log() Error[]:stack.log() panic!()
  end
end

def Until(@pattern @parser @property) end
def Until:prototype.invoke([state str])
  let nodes = []
  while !this:pattern.matches?(str)
    let [result rest_str] = this:parser([nil str])
    nodes:push(result)
    str = rest_str
  end
  return [{...state this:property => nodes} str]
end

def ParseMap(@entries) end
def ParseMap:prototype.invoke([state str])
  if let [_ parser] = this:entries.find(|[pattern _]| pattern.matches?(str))
    return parser([state str])
  else
    this.log([state str])
    panic!("ParseMap failed!")
  end
end

def Trim end
def Trim.invoke([state str]) = [state str:trimLeft()]

def Debug(@msg) end
def Debug:prototype.invoke([state str]) = [state str].log(this:msg)

let digit_regex = /^[+-]?([0-9]*[.])?[0-9]+/

def RegExp:prototype.+(regex) = RegExp[this:source + regex:source]

let parse_class_selector = Parser[
  Init[{kind: :class_selector}]
  Skip["."]
  Store[/^\w+/ :name]
]

let parse_selector_arg = Parser[
  Init[{kind: :selector_arg}]
  Trim Store[/^\w+/ :arg] Trim
]

let parse_pseudo_selector_with_args = Parser[
  Init[{kind: :pseudo_selector_with_args}]
  Skip[":"]
  Store[/^(\w|-)+/ :name]
  Skip["("]
  Trim Until[")" parse_selector_arg :args]
  Trim Skip[")"]
]

let parse_pseudo_selector_without_args = Parser[
  Init[{kind: :pseudo_selector_without_args}]
  Skip[":"]
  Store[/^(\w|-)+/ :name]
]

let parse_pseudo_element_selector = Parser[
  Init[{kind: :pseudo_element_selector}]
  Skip["::"]
  Store[/^(\w|-)+/ :name]
]

let parse_attribute_selector_no_match = Parser[
  Init[{kind: :attribute_selector_no_match}]
  Skip["["]
  Store[/^(\w|-)+/ :name]
  Skip["]"]
]

let parse_attribute_selector_equals = Parser[
  Init[{kind: :attribute_selector_equals}]
  Skip["["]
  Store[/^(\w|-)+/ :name]
  Trim Skip["="]
  Trim Skip["\""]
  Store[/^((?!").)+/ :value]
  Skip["\""]
  Trim Skip["]"]
]

let parse_query_step = ParseMap{
  "." => parse_class_selector
  "::" => parse_pseudo_element_selector
  /^:(\w|-)+\(/ => parse_pseudo_selector_with_args
  ":" => parse_pseudo_selector_without_args
  /^\[(\w|-)+=".*"\]/ => parse_attribute_selector_equals
  /^\[(\w|-)+\]/ => parse_attribute_selector_no_match
}

def parse_query([_ s])
  let [query str] = parse_query_step([nil s])
  while !"{".matches?(str:trimLeft())
    if " ".matches?(str)
      str = str:trimLeft()
      let [query_ str_] = parse_query_step([nil str])
      str = str_
      query = {lhs: query, kind: :child_selector, rhs: query_}
    else
      let [query_ str_] = parse_query_step([nil str])
      str = str_
      query = {lhs: query, kind: :selector_modifier, rhs: query_}
    end
  end
  return [query str]
end

let parse_px_value = Parser[
  Init[{kind: :px_value}]
  Store[digit_regex :value]
  Skip["px"]
]

let parse_vw_value = Parser[
  Init[{kind: :vw_value}]
  Store[digit_regex :value]
  Skip["vw"]
]

let parse_vh_value = Parser[
  Init[{kind: :vh_value}]
  Store[digit_regex :value]
  Skip["vh"]
]

let parse_pct_value = Parser[
  Init[{kind: :pct_value}]
  Store[digit_regex :value]
  Skip["%"]
]

let parse_rgb_value = Parser[
  Init[{kind: :rgb_value}]
  Skip["rgb"]
  Trim Skip["("]
  Trim Store[digit_regex :r]
  Trim Skip[","]
  Trim Store[digit_regex :g]
  Trim Skip[","]
  Trim Store[digit_regex :b]
  Trim Skip[")"]
]

let parse_rgba_value = Parser[
  Init[{kind: :rgba_value}]
  Skip["rgba"]
  Trim Skip["("]
  Trim Store[digit_regex :r]
  Trim Skip[","]
  Trim Store[digit_regex :g]
  Trim Skip[","]
  Trim Store[digit_regex :b]
  Trim Skip[","]
  Trim Store[digit_regex :a]
  Trim Skip[")"]
]

let parse_hex_value = Parser[
  Init[{kind: :hex_value}]
  Skip["#"]
  Trim Store[/^[a-fA-F0-9]{2}/ :r]
  Trim Store[/^[a-fA-F0-9]{2}/ :g]
  Trim Store[/^[a-fA-F0-9]{2}/ :b]
]

let parse_text_value = Parser[
  Init[{kind: :plain_text_value}]
  Store[/^((?!;).)*/ :value]
]

let parse_rem_value = Parser[
  Init[{kind: :rem_value}]
  Store[digit_regex :value]
  Skip["rem"]
]

let parse_em_value = Parser[
  Init[{kind: :em_value}]
  Store[digit_regex :value]
  Skip["em"]]

export let parse_value = ParseMap{
  digit_regex + /px/ => parse_px_value
  digit_regex + /vw/ => parse_vw_value
  digit_regex + /vh/ => parse_vh_value
  digit_regex + /rem/ => parse_rem_value
  digit_regex + /em/ => parse_em_value
  digit_regex + /%/ => parse_pct_value
  "rgba" => parse_rgba_value
  "rgb" => parse_rgb_value
  "#" => parse_hex_value
  _ => parse_text_value
}

let parse_rule = Parser[
  Init[{kind: :rule}]
  Trim Store[/^(\w|-)+/ :name]
  Trim Skip[":"]
  Trim Then[parse_value :value]
  Trim Skip[";"]
]

let parse_variable = Parser[
  Init[{kind: :variable}]
  Trim Skip["--"] Store[/^(\w|-)+/ :name]
  Trim Skip[":"]
  Trim Then[parse_value :value]
  Trim Skip[";"]
]

let parse_statement = Parser[Trim
  ParseMap{"--" => parse_variable _ => parse_rule}
]

let parse_declaration = Parser[
  Init[{kind: :declaration}]
  Trim Then[parse_query :query]
  Trim Skip["{"]
  Until[/^\s*}/ parse_statement :rules]
  Trim Skip["}"]
]

export def parse_decl(string) =
  parse_declaration([nil string])