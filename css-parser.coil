-- TODO: rename this to `test` or something, since ? implies
-- it returns a bool...
export protocol matches?

def String:prototype.matches?(str)
  if str:startsWith(this)
    return {result: this, skip: this.len()}
  else
    return false
  end
end

def RegExp:prototype.matches?(str, group)
  if !group 
    group = 0
  end
  let result = str:match(this)
  if result.nil?() or result:index != 0
    return false
  else
    return {result: result.group, skip: result.0.:length}
  end
end

def _.matches?(str) = {result: str, skip: 0}

-- I live proudly from where I stand, knowing full well how temporary, and ignorant my worldview is.
-- still it has much truth & beauty in it and it has to be expressed

let digit_regex = /^[+-]?([0-9]*[.])?[0-9]+/

def RegExp:prototype.+(regex) = RegExp[this:source + regex:source]

def* generator end
let GeneratorFunction = generator:constructor

export protocol run

def GeneratorFunction:prototype.run(string)
  let gen = this()
  let result = nil
  while true
    let {value, done} = gen:next(result)
    if done
      return [value string]
    else if let [r s] = value.run(string, result)
      result = r
      string = s
    end
  end
end

def ObjectLiteral:prototype.run(string) = this:kind.run(this, string)

def test(pattern) = {kind: :test, pattern: pattern}
def chomp!(pattern) = {kind: :chomp!, pattern: pattern}
def capture(pattern, group) = {kind: :capture, pattern: pattern, group: group or 0}
def capture!(pattern, group) = {kind: :capture!, pattern: pattern, group: group or 0}
def trimmed(parser) = {kind: :trimmed, parser: parser}
def trim = {kind: :trim}
def debug = {kind: :debug}

def :trimmed.run({parser}, string)
  let [result s] = parser.run(string:trimLeft())
  return [result s:trimLeft()]
end

def :test.run({pattern}, string)
  if pattern.matches?(string)
    return [true string]
  else
    return [false string]
  end
end

def :chomp!.run({pattern}, string)
  if let {skip} = pattern.matches?(string)
    return [nil string:slice(skip)]
  else
    this.log({pattern: pattern}, string) Error[]:stack.log() panic!()
  end
end

def :capture.run({pattern, group}, string)
  if let {result skip} = pattern.matches?(string, group)
    -- I think this is broken!
    return [result string]
  else
    return [nil string]
  end
end

def :capture!.run({pattern, group}, string)
  if let {result skip} = pattern.matches?(string, group)
    return [result string:slice(skip)]
  else
    this.log({pattern: pattern, group: group}, string) Error[]:stack.log() panic!()
  end
end

def :trim.run(_, string) = [nil string:trimLeft()]

def :debug.run(_, string, state) = [[state string], string]

def* parse_class_selector
  yield chomp!(".")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :class_selector, name: name}
end

def* parse_selector_arg
  if let factor = yield capture(/^(\d)+n/, 1)
    if yield trimmed(test("+"))
      let offset = yield capture!(/^\d+/)
      return {kind: :nth_expr_with_plus, factor: factor, offset: offset}
    else
      return {kind: :nth_expr_without_plus, factor: factor}
    end
  else
    return yield* parse_query(/^\s*(,|\))/)
  end
end

def* parse_pseudo_selector_with_args
  yield chomp!(":")
  let name = yield capture!(/^(\w|-)+/)
  yield chomp!("(")
  let args = []
  while !yield test(")")
    args:push(yield* parse_selector_arg())
    if !yield test(")")
      yield trimmed(chomp!(","))
    end
  end
  yield chomp!(")")
  return {kind: :pseudo_selector_with_args, name: name, args: args}
end

def* parse_pseudo_selector_without_args
  yield chomp!(":")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :pseudo_selector_without_args, name: name}
end  

def* parse_pseudo_element_selector
  yield chomp!("::")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :pseudo_element_selector, name: name}
end

def* parse_attribute_selector_no_match
  yield chomp!("[")
  let name = yield capture!(/^(\w|-)+/)
  yield chomp!("]")
  return {kind: :attribute_selector_no_match, name: name}
end

def* parse_attribute_selector_equals
  yield chomp!("[")
  let name = yield capture!(/^(\w|-)+/)
  yield trimmed(chomp!("="))
  yield chomp!("\"")
  let value = yield capture!(/^((?!").)+/)
  yield chomp!("\"")
  yield trimmed(chomp!("]"))
  return {kind: :attribute_selector_equals, name: name, value: value}
end

def* parse_element_selector
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :element_selector, name: name}
end

def* parse_query_step
  if yield test(".")
    return yield* parse_class_selector()
  else if yield test("::")
    return yield* parse_pseudo_element_selector()
  else if yield test(/^(\w|-)+/)
    return yield* parse_element_selector()
  else if yield test(/^:(\w|-)+\(/)
    return yield* parse_pseudo_selector_with_args()
  else if yield test(":")
    return yield* parse_pseudo_selector_without_args()
  else if yield test(/^\[(\w|-)+=".*"\]/)
    return yield* parse_attribute_selector_equals()
  else if yield test(/^\[(\w|-)+\]/)
    return yield* parse_attribute_selector_no_match()
  else
    (yield debug()).log()
    panic!("parse fail")
  end
end

def* parse_query(end_pattern)
  let query = yield* parse_query_step()
  while !yield test(end_pattern)
    let kind = nil
    if yield trimmed(test(">"))
      yield trimmed(chomp!(">"))
      kind = :direct_descendent
    else if yield test(" ")
      yield trim()
      kind = :child_selector
    else
      kind = :selector_modifier
    end
    let rhs = yield* parse_query_step()
    query = {kind: kind, lhs: query, rhs: rhs}
  end
  return query
end

def* parse_px_value
  let value = yield capture!(digit_regex)
  yield chomp!("px")
  return {kind: :px_value, value: value}
end

def* parse_vw_value
  let value = yield capture!(digit_regex)
  yield chomp!("vw")
  return {kind: :vw_value, value: value}
end

def* parse_vh_value
  let value = yield capture!(digit_regex)
  yield chomp!("vh")
  return {kind: :vh_value, value: value}
end

def* parse_pct_value
  let value = yield capture!(digit_regex)
  yield chomp!("%")
  return {kind: :pct_value, value: value}
end

def* parse_rgb_value
  yield chomp!("rgb")
  yield trimmed(chomp!("("))
  let r = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let g = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let b = yield capture!(digit_regex)
  yield trimmed(chomp!(")"))
  return {kind: :rgb_value, r: r, g: g, b: b}
end

def* parse_rgba_value
  yield chomp!("rgba")
  yield trimmed(chomp!("("))
  let r = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let g = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let b = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let a = yield capture!(digit_regex)
  yield trimmed(chomp!(")"))
  return {kind: :rgba_value, r: r, g: g, b: b, a: a}
end

def* parse_hex_value
  yield chomp!("#")
  let r = yield trimmed(capture!(/^[a-fA-F0-9]{2}/))
  let g = yield trimmed(capture!(/^[a-fA-F0-9]{2}/))
  let b = yield trimmed(capture!(/^[a-fA-F0-9]{2}/))
  return {kind: :hex_value, r: r, g: g, b: b}
end

def* parse_text_value
  let value = yield capture!(/^((?!;).)*/)
  return {kind: :plain_text_value, value: value}
end

def* parse_rem_value
  let value = yield capture!(digit_regex)
  yield chomp!("rem")
  return {kind: :rem_value, value: value}
end

def* parse_em_value
  let value = yield capture!(digit_regex)
  yield chomp!("em")
  return {kind: :em_value, value: value}
end

def* parse_var_value
  yield chomp!("var")
  yield trimmed(chomp!("("))
  let name = yield capture!(/^--(\w|-)+/)
  yield trimmed(chomp!(")"))
  return {kind: :var_value, name: name}
end

def* parse_var_with_default_value
  yield chomp!("var")
  yield trimmed(chomp!("("))
  let name = yield capture!(/^--(\w|-)+/)
  yield trimmed(chomp!(","))
  let default_value = yield* t_parse_value()
  yield trimmed(chomp!(")"))
  return {kind: :var_with_default_value, name: name, default_value: default_value}
end

def* parse_string_value
  let value = yield capture!(/^".*"/)
  return {kind: :string_value, value: value}
end

export def* parse_value
  if yield test("rgba")
    return yield* parse_rgba_value()
  else if yield test("rgb")
    return yield* parse_rgb_value()
  else if yield test("#")
    return yield* parse_hex_value()
  else if yield test("\"")
    return yield* parse_string_value()
  else if yield test(digit_regex + /px/)
    return yield* parse_px_value()
  else if yield test(digit_regex + /vw/)
    return yield* parse_vw_value()
  else if yield test(digit_regex + /vh/)
    return yield* parse_vh_value()
  else if yield test(digit_regex + /rem/)
    return yield* parse_rem_value()
  else if yield test(digit_regex + /em/)
    return yield* parse_em_value()
  else if yield test(digit_regex + /%/)
    return yield* parse_pct_value()
  else if yield test(/^var\(--(\w|-)+\)/)
    return yield* parse_var_value()
  else if yield test("var")
    return yield* parse_var_with_default_value()
  else
    return yield* parse_text_value()
  end
end

export def* parse_rule
  let name = yield trimmed(capture!(/^(\w|-)+/))
  yield trimmed(chomp!(":"))
  let value = yield* parse_value()
  yield trimmed(chomp!(";"))
  return {kind: :rule, name: name, value: value}
end

def* parse_variable
  let name = yield trimmed(capture!(/^--(\w|-)+/))
  yield trimmed(chomp!(":"))
  let value = yield* parse_value()
  yield trimmed(chomp!(";"))
  return {kind: :variable, name: name, value: value}
end

def* parse_statement
  if yield test("--")
    return yield* parse_variable()
  else
    return yield* parse_rule()
  end
end

export def* parse_declaration
  yield trim()
  let query = yield* parse_query(/^\s*{/)
  yield trimmed(chomp!("{"))
  let rules = []
  while !yield trimmed(test("}"))
    rules:push(yield* parse_statement())
  end
  yield trimmed(chomp!("}"))
  return {kind: :declaration, query: query, rules: rules}
end
