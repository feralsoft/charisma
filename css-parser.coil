-- TODO: rename this to `test` or something, since ? implies
-- it returns a bool...
export protocol matches?

def String:prototype.matches?(str)
  if str:startsWith(this)
    return {result: this, skip: this.len()}
  else
    return false
  end
end

def RegExp:prototype.matches?(str)
  let result = str:match(this)
  if result.nil?() or result:index != 0
    return false
  else
    return {result: result.0, skip: result.0.:length}
  end
end

def _.matches?(str) = {result: str, skip: 0}

export def Parser(...@steps) end
def Parser:prototype.invoke([_ str]) =
  this:steps.reduce(|[result str] parser| parser([result str]), [nil str])

let nid_count = 1
export def Init(@state) end
def Init:prototype.invoke([_ str])
  let nid = nid_count
  nid_count = nid_count + 1
  return [{...this:state nid: nid} str]
end

export def Then(@parser @property) end
def Then:prototype.invoke([state str]) = this:parser([state str])
  .pipe(|[result str]| [{...state this:property => result} str])

export def Skip(@pattern) end
def Skip:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [state str:slice(skip)]
  else
    this.log({state: state, str: str}) Error[]:stack.log() panic!()
  end
end

-- I live proudly from where I stand, knowing full well how temporary, and ignorant my worldview is.
-- still it has much truth & beauty in it and it has to be expressed

export def Store(@pattern @property) end
def Store:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [{...state this:property => result} str:slice(skip)]
  else
    this.log() Error[]:stack.log() panic!()
  end
end

def Until(@pattern @parser @property) end
def Until:prototype.invoke([state str])
  let nodes = []
  while !this:pattern.matches?(str)
    let [result rest_str] = this:parser([nil str])
    nodes:push(result)
    str = rest_str
  end
  return [{...state this:property => nodes} str]
end

def ParseMap(@entries) end
def ParseMap:prototype.invoke([state str])
  if let [_ parser] = this:entries.find(|[pattern _]| pattern.matches?(str))
    return parser([state str])
  else
    this.log([state str])
    panic!("ParseMap failed!")
  end
end

def Trim end
def Trim.invoke([state str]) = [state str:trimLeft()]

def Debug(@msg) end
def Debug:prototype.invoke([state str]) = [state str].log(this:msg)

let digit_regex = /^[+-]?([0-9]*[.])?[0-9]+/

def RegExp:prototype.+(regex) = RegExp[this:source + regex:source]

def* generator end
let GeneratorFunction = generator:constructor

protocol run

def GeneratorFunction:prototype.run(string)
  let gen = this()
  let result = nil
  while true
    let {value, done} = gen:next(result)
    if done
      return [value string]
    else
      let r = value.run(string)
      result = r.0
      string = r.1
    end
  end
end

def ObjectLiteral:prototype.run(string) = this:kind.run(this, string)

def chomp(pattern) = {kind: :chomp, pattern: pattern}
def capture(pattern) = {kind: :capture, pattern: pattern}
def test(pattern) = {kind: :test, pattern: pattern}
def trim = {kind: :trim}

def :chomp.run({pattern}, string)
  if let {skip} = pattern.matches?(string)
    return [nil string:slice(skip)]
  else
    this.log(string) Error[]:stack.log() panic!()
  end
end

def :capture.run({pattern}, string)
  if let {result skip} = pattern.matches?(string)
    return [result string:slice(skip)]
  else
    this.log(string) Error[]:stack.log() panic!()
  end
end

def :trim.run(_, string) = [nil string:trimLeft()]

def :test.run({pattern}, string) = [pattern.matches?(string) string]

def* parse_class
  yield chomp(".")
  let name = yield capture(/^(\w|-)+/)
  return {kind: :class_selector, name: name}
end

def parse_class_selector([_ string]) = parse_class.run(string)

def* parse_nth_expr_without_plus
  let lhs = yield capture(/^/)
  yield chomp("2n")
  return {kind: :nth_expr_without_plus, value: "2n"}
end

def* parse_nth_expr_with_plus
  yield chomp("2n+1")
  return {kind: :nth_expr_with_plus, value: "2n+1"}
end

let parse_selector_arg = ParseMap{
  def /^\d+n\+\d+/([_ string]) = parse_nth_expr_with_plus.run(string)
  def /^\d+n/([_ string]) = parse_nth_expr_without_plus.run(string)
}

let parse_pseudo_selector_with_args = Parser[
  Init[{kind: :pseudo_selector_with_args}]
  Skip[":"]
  Store[/^(\w|-)+/ :name]
  Skip["("]
  Trim Until[")" parse_selector_arg :args]
  Trim Skip[")"]
]

let parse_pseudo_selector_without_args = Parser[
  Init[{kind: :pseudo_selector_without_args}]
  Skip[":"]
  Store[/^(\w|-)+/ :name]
]

let parse_pseudo_element_selector = Parser[
  Init[{kind: :pseudo_element_selector}]
  Skip["::"]
  Store[/^(\w|-)+/ :name]
]
let parse_attribute_selector_no_match = Parser[
  Init[{kind: :attribute_selector_no_match}]
  Skip["["]
  Store[/^(\w|-)+/ :name]
  Skip["]"]
]

let parse_attribute_selector_equals = Parser[
  Init[{kind: :attribute_selector_equals}]
  Skip["["]
  Store[/^(\w|-)+/ :name]
  Trim Skip["="]
  Trim Skip["\""]
  Store[/^((?!").)+/ :value]
  Skip["\""]
  Trim Skip["]"]
]

let parse_element_selector = Parser[
  Init[{kind: :element_selector}]
  Store[/^(\w|-)+/ :name]
]

def parse_query_step(result) = ParseMap{
  "." => parse_class_selector
  "::" => parse_pseudo_element_selector
  /^(\w|-)+/ => parse_element_selector
  /^:(\w|-)+\(/ => parse_pseudo_selector_with_args
  ":" => parse_pseudo_selector_without_args
  /^\[(\w|-)+=".*"\]/ => parse_attribute_selector_equals
  /^\[(\w|-)+\]/ => parse_attribute_selector_no_match
}(result)

def parse_query([_ s])
  let [query str] = parse_query_step([nil s])
  while !"{".matches?(str:trimLeft())
    if " ".matches?(str)
      str = str:trimLeft()
      let [query_ str_] = parse_query_step([nil str])
      str = str_
      query = {lhs: query, kind: :child_selector, rhs: query_}
    else
      let [query_ str_] = parse_query_step([nil str])
      str = str_
      query = {lhs: query, kind: :selector_modifier, rhs: query_}
    end
  end
  return [query str]
end

let parse_px_value = Parser[
  Init[{kind: :px_value}]
  Store[digit_regex :value]
  Skip["px"]
]

let parse_vw_value = Parser[
  Init[{kind: :vw_value}]
  Store[digit_regex :value]
  Skip["vw"]
]

let parse_vh_value = Parser[
  Init[{kind: :vh_value}]
  Store[digit_regex :value]
  Skip["vh"]
]

let parse_pct_value = Parser[
  Init[{kind: :pct_value}]
  Store[digit_regex :value]
  Skip["%"]
]

let parse_rgb_value = Parser[
  Init[{kind: :rgb_value}]
  Skip["rgb"]
  Trim Skip["("]
  Trim Store[digit_regex :r]
  Trim Skip[","]
  Trim Store[digit_regex :g]
  Trim Skip[","]
  Trim Store[digit_regex :b]
  Trim Skip[")"]
]

let parse_rgba_value = Parser[
  Init[{kind: :rgba_value}]
  Skip["rgba"]
  Trim Skip["("]
  Trim Store[digit_regex :r]
  Trim Skip[","]
  Trim Store[digit_regex :g]
  Trim Skip[","]
  Trim Store[digit_regex :b]
  Trim Skip[","]
  Trim Store[digit_regex :a]
  Trim Skip[")"]
]

let parse_hex_value = Parser[
  Init[{kind: :hex_value}]
  Skip["#"]
  Trim Store[/^[a-fA-F0-9]{2}/ :r]
  Trim Store[/^[a-fA-F0-9]{2}/ :g]
  Trim Store[/^[a-fA-F0-9]{2}/ :b]
]

let parse_text_value = Parser[
  Init[{kind: :plain_text_value}]
  Store[/^((?!;).)*/ :value]
]

let parse_rem_value = Parser[
  Init[{kind: :rem_value}]
  Store[digit_regex :value]
  Skip["rem"]
]

let parse_em_value = Parser[
  Init[{kind: :em_value}]
  Store[digit_regex :value]
  Skip["em"]]

let parse_var_value = Parser[
  Init[{kind: :var_value}]
  Skip["var"] Trim Skip["("] Trim
  Store[/^--(\w|-)+/ :name]
  Trim Skip[")"]
]

def parse_var_with_default_value(result) = Parser[
  Init[{kind: :var_with_default_value}]  
  Skip["var"] Trim Skip["("] Trim Skip["--"]
  Store[/^(\w|-)+/ :name]
  Trim Skip[","] Trim
  Then[parse_value :default_value]
  Trim Skip[")"]
](result)

let parse_string_value = Parser[
  Init[{kind: :string_value}]
  Store[/^".*"/ :value]  
]

export let parse_value = ParseMap{
  "rgba" => parse_rgba_value
  "rgb" => parse_rgb_value
  "#" => parse_hex_value
  "\"" => parse_string_value
  digit_regex + /px/ => parse_px_value
  digit_regex + /vw/ => parse_vw_value
  digit_regex + /vh/ => parse_vh_value
  digit_regex + /rem/ => parse_rem_value
  digit_regex + /em/ => parse_em_value
  digit_regex + /%/ => parse_pct_value
  /^var\(--(\w|-)+\)/ => parse_var_value
  "var" => parse_var_with_default_value
  _ => parse_text_value
}

let parse_rule = Parser[
  Init[{kind: :rule}]
  Trim Store[/^(\w|-)+/ :name]
  Trim Skip[":"]
  Trim Then[parse_value :value]
  Trim Skip[";"]
]

let parse_variable = Parser[
  Init[{kind: :variable}]
  Trim Store[/^--(\w|-)+/ :name]
  Trim Skip[":"]
  Trim Then[parse_value :value]
  Trim Skip[";"]
]

let parse_statement = Parser[Trim
  ParseMap{"--" => parse_variable _ => parse_rule}
]

let parse_declaration = Parser[
  Init[{kind: :declaration}]
  Trim Then[parse_query :query]
  Trim Skip["{"]
  Until[/^\s*}/ parse_statement :rules]
  Trim Skip["}"]
]

export def parse_decl(string) =
  parse_declaration([nil string])