-- TODO: rename this to `test` or something, since ? implies
-- it returns a bool...
export protocol matches?

def String:prototype.matches?(str)
  if str:startsWith(this)
    return {result: this, skip: this.len()}
  else
    return false
  end
end

def RegExp:prototype.matches?(str, group)
  if !group 
    group = 0
  end
  let result = str:match(this)
  if result.nil?() or result:index != 0
    return false
  else
    return {result: result.group, skip: result.0.:length}
  end
end

def _.matches?(str) = {result: str, skip: 0}

export def Parser(...@steps) end
def Parser:prototype.invoke([_ str]) =
  this:steps.reduce(|[result str] parser| parser([result str]), [nil str])

let nid_count = 1
export def Init(@state) end
def Init:prototype.invoke([_ str])
  let nid = nid_count
  nid_count = nid_count + 1
  return [{...this:state nid: nid} str]
end

export def Then(@parser @property) end
def Then:prototype.invoke([state str]) = this:parser([state str])
  .pipe(|[result str]| [{...state this:property => result} str])

export def Skip(@pattern) end
def Skip:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [state str:slice(skip)]
  else
    this.log({state: state, str: str}) Error[]:stack.log() panic!()
  end
end

-- I live proudly from where I stand, knowing full well how temporary, and ignorant my worldview is.
-- still it has much truth & beauty in it and it has to be expressed

export def Store(@pattern @property) end
def Store:prototype.invoke([state str])
  if let {result skip} = this:pattern.matches?(str)
    return [{...state this:property => result} str:slice(skip)]
  else
    this.log() Error[]:stack.log() panic!()
  end
end

def Until(@pattern @parser @property) end
def Until:prototype.invoke([state str])
  let nodes = []
  while !this:pattern.matches?(str)
    let [result rest_str] = this:parser([nil str])
    nodes:push(result)
    str = rest_str
  end
  return [{...state this:property => nodes} str]
end

def ParseMap(@entries) end
def ParseMap:prototype.invoke([state str])
  if let [_ parser] = this:entries.find(|[pattern _]| pattern.matches?(str))
    return parser([state str])
  else
    this.log([state str])
    panic!("ParseMap failed!")
  end
end

def Trim end
def Trim.invoke([state str]) = [state str:trimLeft()]

def Debug(@msg) end
def Debug:prototype.invoke([state str]) = [state str].log(this:msg)

let digit_regex = /^[+-]?([0-9]*[.])?[0-9]+/

def RegExp:prototype.+(regex) = RegExp[this:source + regex:source]

def* generator end
let GeneratorFunction = generator:constructor

export protocol run

def GeneratorFunction:prototype.run(string)
  let gen = this()
  let result = nil
  while true
    let {value, done} = gen:next(result)
    if done
      return [value string]
    else if let [r s] = value.run(string, result)
      result = r
      string = s
    end
  end
end

def ObjectLiteral:prototype.run(string) = this:kind.run(this, string)

def chomp(pattern) = {kind: :chomp, pattern: pattern}
def chomp!(pattern) = {kind: :chomp!, pattern: pattern}
def capture(pattern, group) = {kind: :capture, pattern: pattern, group: group or 0}
def capture!(pattern, group) = {kind: :capture!, pattern: pattern, group: group or 0}
def trimmed(parser) = {kind: :trimmed, parser: parser}
def trim = {kind: :trim}
def debug = {kind: :debug}

def :trimmed.run({parser}, string)
  let [result s] = parser.run(string:trimLeft())
  return [result s:trimLeft()]
end

def :chomp.run({pattern}, string)
  if pattern.matches?(string)
    return [true string]
  else
    return [false string]
  end
end

def :chomp!.run({pattern}, string)
  if let {skip} = pattern.matches?(string)
    return [nil string:slice(skip)]
  else
    this.log({pattern: pattern}, string) Error[]:stack.log() panic!()
  end
end

def :capture.run({pattern, group}, string)
  if let {result skip} = pattern.matches?(string, group)
    return [result string]
  else
    return [nil string]
  end
end

def :capture!.run({pattern, group}, string)
  if let {result skip} = pattern.matches?(string, group)
    return [result string:slice(skip)]
  else
    this.log({pattern: pattern, group: group}, string) Error[]:stack.log() panic!()
  end
end

def :trim.run(_, string) = [nil string:trimLeft()]

def :debug.run(_, string, state) = [[state string], string]

def* parse_class_selector
  yield chomp!(".")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :class_selector, name: name}
end

def* parse_nth_expr_without_plus
  yield chomp!("2n")
  return {kind: :nth_expr_without_plus, value: "2n"}
end

def* parse_nth_expr_with_plus
  yield chomp!("2n+1")
  return {kind: :nth_expr_with_plus, value: "2n+1"}
end

def* parse_selector_arg
  if let factor = yield capture(/^(\d)+n/, 1)
    if yield trimmed(chomp("+"))
      let offset = yield capture!(/^\d+/)
      return {kind: :nth_expr_with_plus, factor: factor, offset: offset}
    else
      return {kind: :nth_expr_without_plus, factor: factor}
    end
  end
end

def* parse_pseudo_selector_with_args
  yield chomp!(":")
  let name = yield capture!(/^(\w|-)+/)
  yield chomp!("(")
  let args = []
  while !yield chomp(")")
    args:push(yield* parse_selector_arg())
  end
  return {kind: :pseudo_selector_with_args, name: name, args: args}
end

def* parse_pseudo_selector_without_args
  yield chomp!(":")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :pseudo_selector_without_args, name: name}
end  

def* parse_pseudo_element_selector
  yield chomp!("::")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :pseudo_element_selector, name: name}
end

def* parse_attribute_selector_no_match
  yield chomp!("[")
  let name = yield capture!(/^(\w|-)+/)
  yield chomp!("]")
  return {kind: :attribute_selector_no_match, name: name}
end

def* parse_attribute_selector_equals
  yield chomp!("[")
  let name = yield capture!(/^(\w|-)+/)
  yield trimmed(chomp!("="))
  yield chomp!("\"")
  let value = yield capture!(/^((?!").)+/)
  yield chomp!("\"")
  yield trimmed(chomp!("]"))
  return {kind: :attribute_selector_equals, name: name, value: value}
end

def* parse_element_selector
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :element_selector, name: name}
end

def* t_parse_query_step
  if yield chomp(".")
    return yield* parse_class_selector()
  else if yield chomp("::")
    return yield* parse_pseudo_element_selector()
  else if yield chomp(":")
    return yield* parse_pseudo_selector_without_args()
  else if yield chomp(/^(\w|-)+/)
    return yield* parse_element_selector()
  else if yield chomp(/^:(\w|-)+\(/)
    return yield* parse_pseudo_selector_with_args()
  else if yield chomp(/^\[(\w|-)+=".*"\]/)
    return yield* parse_attribute_selector_equals()
  else if yield chomp(/^\[(\w|-)+\]/)
    return yield* parse_attribute_selector_no_match()
  end
end

def parse_query_step([_ string]) = t_parse_query_step.run(string)

def parse_query([_ s])
  let [query str] = parse_query_step([nil s])
  while !"{".matches?(str:trimLeft())
    if " ".matches?(str)
      str = str:trimLeft()
      let [query_ str_] = parse_query_step([nil str])
      str = str_
      query = {lhs: query, kind: :child_selector, rhs: query_}
    else
      let [query_ str_] = parse_query_step([nil str])
      str = str_
      query = {lhs: query, kind: :selector_modifier, rhs: query_}
    end
  end
  return [query str]
end

def* t_parse_px_value
  let value = yield capture!(digit_regex)
  yield chomp!("px")
  return {kind: :px_value, value: value}
end

def parse_px_value([_ s]) = t_parse_px_value.run(s)

def* t_parse_vw_value
  let value = yield capture!(digit_regex)
  yield chomp!("vw")
  return {kind: :vw_value, value: value}
end

def parse_vw_value([_ s]) = t_parse_vw_value.run(s)

def* t_parse_vh_value
  let value = yield capture!(digit_regex)
  yield chomp!("vh")
  return {kind: :vh_value, value: value}
end

def parse_vh_value([_ s]) = t_parse_vh_value.run(s)

def* t_parse_pct_value
  let value = yield capture!(digit_regex)
  yield chomp!("%")
  return {kind: :pct_value, value: value}
end

def parse_pct_value([_ s]) = t_parse_pct_value.run(s)

def* t_parse_rgb_value
  yield chomp!("rgb")
  yield trimmed(chomp!("("))
  let r = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let g = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let b = yield capture!(digit_regex)
  yield trimmed(chomp!(")"))
  return {kind: :rgb_value, r: r, g: g, b: b}
end

def parse_rgb_value([_ s]) = t_parse_rgb_value.run(s)

def* t_parse_rgba_value
  yield chomp!("rgba")
  yield trimmed(chomp!("("))
  let r = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let g = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let b = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let a = yield capture!(digit_regex)
  yield trimmed(chomp!(")"))
  return {kind: :rgba_value, r: r, g: g, b: b, a: a}
end

def parse_rgba_value([_ s]) = t_parse_rgba_value.run(s)

let parse_hex_value = Parser[
  Init[{kind: :hex_value}]
  Skip["#"]
  Trim Store[/^[a-fA-F0-9]{2}/ :r]
  Trim Store[/^[a-fA-F0-9]{2}/ :g]
  Trim Store[/^[a-fA-F0-9]{2}/ :b]
]

let parse_text_value = Parser[
  Init[{kind: :plain_text_value}]
  Store[/^((?!;).)*/ :value]
]

let parse_rem_value = Parser[
  Init[{kind: :rem_value}]
  Store[digit_regex :value]
  Skip["rem"]
]

let parse_em_value = Parser[
  Init[{kind: :em_value}]
  Store[digit_regex :value]
  Skip["em"]]

let parse_var_value = Parser[
  Init[{kind: :var_value}]
  Skip["var"] Trim Skip["("] Trim
  Store[/^--(\w|-)+/ :name]
  Trim Skip[")"]
]

def parse_var_with_default_value(result) = Parser[
  Init[{kind: :var_with_default_value}]  
  Skip["var"] Trim Skip["("] Trim Skip["--"]
  Store[/^(\w|-)+/ :name]
  Trim Skip[","] Trim
  Then[parse_value :default_value]
  Trim Skip[")"]
](result)

let parse_string_value = Parser[
  Init[{kind: :string_value}]
  Store[/^".*"/ :value]  
]

export let parse_value = ParseMap{
  "rgba" => parse_rgba_value
  "rgb" => parse_rgb_value
  "#" => parse_hex_value
  "\"" => parse_string_value
  digit_regex + /px/ => parse_px_value
  digit_regex + /vw/ => parse_vw_value
  digit_regex + /vh/ => parse_vh_value
  digit_regex + /rem/ => parse_rem_value
  digit_regex + /em/ => parse_em_value
  digit_regex + /%/ => parse_pct_value
  /^var\(--(\w|-)+\)/ => parse_var_value
  "var" => parse_var_with_default_value
  _ => parse_text_value
}

export let parse_rule = Parser[
  Init[{kind: :rule}]
  Trim Store[/^(\w|-)+/ :name]
  Trim Skip[":"]
  Trim Then[parse_value :value]
  Trim Skip[";"]
]

let parse_variable = Parser[
  Init[{kind: :variable}]
  Trim Store[/^--(\w|-)+/ :name]
  Trim Skip[":"]
  Trim Then[parse_value :value]
  Trim Skip[";"]
]

let parse_statement = Parser[Trim
  ParseMap{"--" => parse_variable _ => parse_rule}
]

let parse_declaration = Parser[
  Init[{kind: :declaration}]
  Trim Then[parse_query :query]
  Trim Skip["{"]
  Until[/^\s*}/ parse_statement :rules]
  Trim Skip["}"]
]

export def parse_decl(string) =
  parse_declaration([nil string])