import {test, capture!, chomp!, trimmed, trim, debug} from "./parse-utils.coil"

let digit_regex = /^[+-]?([0-9]*[.])?[0-9]+/

def* parse_class_selector
  yield chomp!(".")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :class_selector, name}
end

def* parse_selector_arg
  if yield test(/^\d+n/)
    let factor = yield capture!(/^(\d)+n/, 1)
    if yield trimmed(test("+"))
      let offset = yield capture!(/^\d+/)
      return {kind: :nth_expr_with_plus, factor, offset}
    else
      return {kind: :nth_expr_without_plus, factor}
    end
  else
    return yield* parse_query(/^\s*(,|\))/)
  end
end

def* parse_pseudo_selector_with_args
  yield chomp!(":")
  let name = yield capture!(/^(\w|-)+/)
  yield chomp!("(")
  let args = []
  while !yield test(")")
    args:push(yield* parse_selector_arg())
    if !yield test(")")
      yield trimmed(chomp!(","))
    end
  end
  yield chomp!(")")
  return {kind: :pseudo_selector_with_args, name, args}
end

def* parse_pseudo_selector_without_args
  yield chomp!(":")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :pseudo_selector_without_args, name}
end  

def* parse_pseudo_element_selector
  yield chomp!("::")
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :pseudo_element_selector, name}
end

def* parse_attribute_selector_no_match
  yield chomp!("[")
  let name = yield capture!(/^(\w|-)+/)
  yield chomp!("]")
  return {kind: :attribute_selector_no_match, name}
end

def* parse_attribute_selector_equals
  yield chomp!("[")
  let name = yield capture!(/^(\w|-)+/)
  yield trimmed(chomp!("="))
  yield chomp!("\"")
  let value = yield capture!(/^((?!").)+/)
  yield chomp!("\"")
  yield trimmed(chomp!("]"))
  return {kind: :attribute_selector_equals, name, value}
end

def* parse_element_selector
  let name = yield capture!(/^(\w|-)+/)
  return {kind: :element_selector, name}
end

def* parse_query_step
  if yield test(".")
    return yield* parse_class_selector()
  else if yield test("::")
    return yield* parse_pseudo_element_selector()
  else if yield test(/^(\w|-)+/)
    return yield* parse_element_selector()
  else if yield test(/^:(\w|-)+\(/)
    return yield* parse_pseudo_selector_with_args()
  else if yield test(":")
    return yield* parse_pseudo_selector_without_args()
  else if yield test(/^\[(\w|-)+=".*"\]/)
    return yield* parse_attribute_selector_equals()
  else if yield test(/^\[(\w|-)+\]/)
    return yield* parse_attribute_selector_no_match()
  else
    (yield debug()).log()
    panic!("parse fail")
  end
end

def* parse_query(end_pattern)
  let query = yield* parse_query_step()
  while !yield test(end_pattern)
    let kind = nil
    if yield trimmed(test(">"))
      yield trimmed(chomp!(">"))
      kind = :direct_descendent
    else if yield test(" ")
      yield trim()
      kind = :child_selector
    else
      kind = :selector_modifier
    end
    let rhs = yield* parse_query_step()
    query = {kind, lhs: query, rhs}
  end
  return query
end

def* parse_px_value
  let value = yield capture!(digit_regex)
  yield chomp!("px")
  return {kind: :px, value}
end

def* parse_vw_value
  let value = yield capture!(digit_regex)
  yield chomp!("vw")
  return {kind: :vw, value}
end

def* parse_vh_value
  let value = yield capture!(digit_regex)
  yield chomp!("vh")
  return {kind: :vh, value}
end

def* parse_pct_value
  let value = yield capture!(digit_regex)
  yield chomp!("%")
  return {kind: :pct, value}
end

def* parse_rgb_value
  yield chomp!("rgb")
  yield trimmed(chomp!("("))
  let r = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let g = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let b = yield capture!(digit_regex)
  yield trimmed(chomp!(")"))
  return {kind: :rgb, r, g, b}
end

def* parse_rgba_value
  yield chomp!("rgba")
  yield trimmed(chomp!("("))
  let r = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let g = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let b = yield capture!(digit_regex)
  yield trimmed(chomp!(","))
  let a = yield capture!(digit_regex)
  yield trimmed(chomp!(")"))
  return {kind: :rgba, r, g, b, a}
end

let hex_part_regex = /^[a-fA-F0-9]{2}/

def* parse_hex_value
  yield chomp!("#")
  let r = yield trimmed(capture!(hex_part_regex))
  let g = yield trimmed(capture!(hex_part_regex))
  let b = yield trimmed(capture!(hex_part_regex))
  return {kind: :hex, r, g, b}
end

def* parse_text_value
  let value = yield capture!(/^((?!;).)*/)
  return {kind: :plain_text, value}
end

def* parse_rem_value
  let value = yield capture!(digit_regex)
  yield chomp!("rem")
  return {kind: :rem, value}
end

def* parse_em_value
  let value = yield capture!(digit_regex)
  yield chomp!("em")
  return {kind: :em, value}
end

def* parse_var_value
  yield chomp!("var")
  yield trimmed(chomp!("("))
  let name = yield capture!(/^--(\w|-)+/)
  yield trimmed(chomp!(")"))
  return {kind: :var, name}
end

def* parse_var_with_default_value
  yield chomp!("var")
  yield trimmed(chomp!("("))
  let name = yield capture!(/^--(\w|-)+/)
  yield trimmed(chomp!(","))
  let default_value = yield* t_parse_value()
  yield trimmed(chomp!(")"))
  return {kind: :var_with_default, name, default_value}
end

def* parse_string_value
  let value = yield capture!(/^".*"/)
  return {kind: :string, value}
end

export def* parse_value
  if yield test("rgba")
    return yield* parse_rgba_value()
  else if yield test("rgb")
    return yield* parse_rgb_value()
  else if yield test("#")
    return yield* parse_hex_value()
  else if yield test("\"")
    return yield* parse_string_value()
  else if yield test(digit_regex + /px/)
    return yield* parse_px_value()
  else if yield test(digit_regex + /vw/)
    return yield* parse_vw_value()
  else if yield test(digit_regex + /vh/)
    return yield* parse_vh_value()
  else if yield test(digit_regex + /rem/)
    return yield* parse_rem_value()
  else if yield test(digit_regex + /em/)
    return yield* parse_em_value()
  else if yield test(digit_regex + /%/)
    return yield* parse_pct_value()
  else if yield test(/^var\(--(\w|-)+\)/)
    return yield* parse_var_value()
  else if yield test("var")
    return yield* parse_var_with_default_value()
  else
    return yield* parse_text_value()
  end
end

export def* parse_rule
  let name = yield trimmed(capture!(/^(\w|-)+/))
  yield trimmed(chomp!(":"))
  let value = yield* parse_value()
  yield trimmed(chomp!(";"))
  return {kind: :rule, name, value}
end

def* parse_variable
  let name = yield trimmed(capture!(/^--(\w|-)+/))
  yield trimmed(chomp!(":"))
  let value = yield* parse_value()
  yield trimmed(chomp!(";"))
  return {kind: :variable, name, value}
end

def* parse_statement
  if yield test("--")
    return yield* parse_variable()
  else
    return yield* parse_rule()
  end
end

export def* parse_decl
  yield trim()
  let query = yield* parse_query(/^\s*{/)
  yield trimmed(chomp!("{"))
  let rules = []
  while !yield trimmed(test("}"))
    rules:push(yield* parse_statement())
  end
  yield trimmed(chomp!("}"))
  return {kind: :decl, query, rules}
end
